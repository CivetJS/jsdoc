/**
 * Function is called by JSDocs deucumentation generator. function takes
 * set of symbols representing the source of the files to be documented.
 * @param {Symbol} symbolSet    Object representing source <i/>(Object can
 * represent class, object, memeber of the class, comment)</i>
 * @param {JSDOC}
 */
exports.publish = function publish(symbolSet) {
    /**
     * Map of files paths and data that will be written.
     * @type {String}
     */
    var docs = {};
    /**
     * Title for the doc pages
     * @type {String}
     */
    var title = 'JSDoc Reference ';
    var footer = 'Documentation generated by JSDocs 0.1 on ' + new Date().toString();
    var header = 'JSDoc Reference';
    var symbols = symbolSet.toArray();
    var css = new Plugins.Template('styles.css').render();

    // Getting classes
    var classes = symbols.filter(function(symbol) {
        return (symbol.is('CONSTRUCTOR') || symbol.isNamespace);
    }).sort(makeSortby('alias'));
    // Getting files
    var files = symbols.filter(function(symbol) {
        return symbol.is('FILE');
    });
    
    var indexTemplate = new Plugins.Template('index.xhtml');
    var classTemplate = new Plugins.Template('class.xhtml');
    
    // Generation template for index page
    docs['index.html'] = indexTemplate.render({
        page: {
            title: title,
            style: css,
            header: header,
            footer: footer
        },
        classes: classes
    });
    docs['styles.css'] = css;
    
    classes.map(function(data) {
        var alias = data.alias;
        // Grouping fields by owners
        var fieldOwners = {};
        data.properties.forEach(function(field) {
            if (!fieldOwners[field.memberOf])
                fieldOwners[field.memberOf] = { self: field.memberOf, fields: [] };
            fieldOwners[field.memberOf].fields.push(field);
        });
        var ownFields = fieldOwners[alias] ? fieldOwners[alias].fields : [];
        delete fieldOwners[alias];
        // Grouping methods by owners
        var methodOwners = {};
        data.methods.forEach(function(method) {
            if(!methodOwners[method.memberOf])
                methodOwners[method.memberOf] = { self: method.memberOf, methods: [] };
            methodOwners[method.memberOf].methods.push(method);
        })
        var ownMethods = methodOwners[alias] ? methodOwners[alias].methods : [];
        delete methodOwners[alias];

        return {
            // Template additions
            page: {
                title: title + alias,
                style: css,
                header: header,
                footer: footer
            },
            // Class name & link
            name: data.name,
            alias: data.alias,
            link: '#' + data.name,
            classDesc: data.classDesc,
            // Class type
            isBuiltin: data.isBuiltin(),
            isConstructor: data.is('CONSTRUCTOR'),
            isFunction: data.is('FUNCTION'),
            isNamespace: data.isNamespace,
            isPrivate: data.isPrivate,
            isInner: data.isInner,
            // Source data
            srcFile: data.srcFile,
            srcLink: data.srcFile,
            // Class extends
            inheritsFrom: data.augments.sort(),
            // Class summary
            hasSummary: (!data.isBuiltin() && (data.isNamespace || data.is('CONSTRUCTOR'))),
            highlighted: (data.comment.getTag("hilited").length ? 'hilited' : ''),
            // constructor
            constructorLink: data.alias,
            params: data.params,
            desc: data.desc,
            // Fields
            //inheritsFrom: data.inheritsFrom,
            fields: data.properties,
            ownFields: ownFields.sort(makeSortby('name')),
            hasInheritedFields: (data.properties.length != ownFields.length),
            fieldOwners: fieldOwners,
            // Methods
            methods: data.methods,
            ownMethods: ownMethods.sort(makeSortby('name')),
            hasInheritedMethods: (data.methods.length != ownMethods.length),
            methodOwners: methodOwners,
            // details
            author: data.author,
            example: data.example,
            // additional
            deprecated: data.deprecated,
            author: data.author,
            see: data.see,
            since: data.since,
            // hack to get an index
            classes: classes
        };
    }).forEach(function(element) {
        var path = element.srcFile || '_global_';
        docs[path + '.' + element.name + '.html'] = classTemplate.render(element);
    });
    
    return docs;
};

function makeSortby(key) {
    return function(a, b) {
        if (a[key] !== undefined && b[key] !== undefined) {
            a = a[key].toLowerCase();
            b = b[key].toLowerCase();
            if (a < b) return -1;
            if (a > b) return 1;
        }
        return 0;
    };
}

